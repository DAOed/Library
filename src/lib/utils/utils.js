
import { maxFileSize, supportedFileExt } from "@constants"
import { initialsAvatar } from "@lib/helpers"
import md5 from "md5"

export const makePath = (parentPath, name) => {
  return parentPath + "/" + name.replace(/\W+/g, "-").toLowerCase()
}

export const validFileType = file => {
  let ext = (file.name.split(".").pop() || "").toUpperCase()
  return supportedFileExt.indexOf(ext) !== -1
}

export const validFileSize = file => {
  return file.size <= maxFileSize
}

export const formatBytes = (bytes = 0, decimals = 2) => {
  if (bytes === 0) return "0 Bytes"

  const k = 1024
  const dm = decimals < 0 ? 0 : decimals
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]

  const i = Math.floor(Math.log(bytes) / Math.log(k))

  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i]
}

export const readLocalFile = (file, mode) => {
  return new Promise((resolve, reject) => {
    let reader = new FileReader()

    reader.onload = () => {
      resolve(reader.result)
    }

    reader.onerror = reject

    switch (mode) {
    case "readAsBinaryString":
      reader.readAsBinaryString(file)
      break
    case "readAsArrayBuffer":
      reader.readAsArrayBuffer(file)
      break
    default:
      reader.readAsDataURL(file)
    }
  })
}

export const readExternalFile = (file, mode) => {
  return new Promise(async (resolve, reject) => {
    fetch(file.url)
      .then(res => res.blob())
      .then(blob => {
        let reader = new FileReader()

        reader.onload = () => {
          let result = reader.result

          let data = {
            name: file.name || file.url.split("/").pop(),
            private: true,
            size: result.length,
            id: md5(result),
            content: result
            // path: '' // will be generated by the creation function
          }
          resolve(data)
        }

        reader.onerror = reject

        switch (mode) {
        case "readAsBinaryString":
          reader.readAsBinaryString(blob)
          break
        case "readAsArrayBuffer":
          reader.readAsArrayBuffer(blob)
          break
        default:
          reader.readAsDataURL(blob)
        }
      })
  })
}

export const uniquifyNames = (arr) => {
  var count = {}
  arr.forEach(function (x, i) {
    if (arr.indexOf(x) !== i) {
      var c = x in count ? count[x] = count[x] + 1 : count[x] = 1
      var j = c + 1
      var k = fileName(x) + "(" + j + ")." + fileExt(x)

      while (arr.indexOf(k) !== -1) k = fileName(x) + "(" + (++j) + ")." + fileExt(x)
      arr[i] = k
    }
  })
  return arr
}

export const fileName = (name) => {
  let parts = name.split(".")
  return parts.slice(0, parts.length - 1).join(".")
}

export const fileExt = (name) => name.split(".").pop()

export const uniquifyNewFileNames = (oldFiles, newFiles) => {
// get names
  let oldNames = oldFiles.map(({ name }) => name)
  let newNames = newFiles.map(({ name }) => name)

  // check for duplicates in new items
  let allNames = [...oldNames, ...newNames]

  // make names unique
  let uniqueNames = uniquifyNames(allNames)
  let newUniqueNames = uniqueNames.slice(oldFiles.length)

  return newUniqueNames.map((nom, index) => {
    return {
      ...newFiles[index],
      name: newUniqueNames[index]
    }
  })
}

export const makeFileNameUnique = (oldFiles, newFiles) => {
  let uniqueFiles = uniquifyNewFileNames(oldFiles, newFiles)
  return uniqueFiles[0]
}

export const schemeAccounts = (accs = []) => {
  return accs.map((acc) => {
    const profile = acc.profile || {}

    const name = (profile.name || "").substring(0, 30) || acc.username
    const bio = (profile.description || "").substring(0, 300)
    const avatar = ((profile.image || []).find((i) => i.name === "avatar") || {}).contentUrl || initialsAvatar(acc.username)
    const username = acc.username

    return { name, bio, avatar, username }
  })
}
